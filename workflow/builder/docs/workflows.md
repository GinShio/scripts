# Workflow & Identity Resolution Strategy

This document outlines the architectural design for supporting hybrid development workflows in the Builder CLI. It details how we resolve a stable "Identity" for the current workspace state, enabling persistent build directories across both traditional Branch-based workflows and modern Stacked Diffs workflows (e.g., `git-branchless`).

---

## The Challenge: Identity in a Detached World

In a traditional **Branch-based workflow**, the "Branch Name" serves as a stable identity. Developers switch branches (`feature/A` -> `feature/B`), and the build system switches contexts accordingly (`build/feature_A` -> `build/feature_B`).

In a **Stacked Diffs workflow**, developers frequently operate in a **Detached HEAD** state. They navigate up and down a stack of commits, modifying them in place (`amend`, `rebase`).
- Relying solely on `HEAD` (Branch Name) often results in a generic `detached` state.
- Relying solely on Commit Hash results in unstable build directories (every `amend` changes the hash, triggering a full rebuild).

To support both workflows simultaneously, we introduce a **5-Layer Identity Resolution Waterfall**.

---

## The 5-Layer Identity Resolution Waterfall

The Builder CLI determines the workspace identity (and thus the build directory name) by evaluating the following layers in order. The first layer to return a valid result wins.

### Layer 1: Explicit Branch Name (The "Checkout" Layer)
**Priority:** Highest
**Check:** Is `HEAD` a symbolic reference to a branch? (`git symbolic-ref --short HEAD`)

This represents the strongest user intent. If you have explicitly checked out a branch, we honor that branch name as the identity. This ensures 100% backward compatibility with traditional workflows.

- **Scenario:** User runs `git checkout feature/vulkan`.
- **Identity:** `feature_vulkan`
- **Stability:** ⭐⭐⭐⭐⭐ (Stable until branch switch)

### Layer 2: Implicit Branch / Ref Tip (The "Stack Top" Layer)
**Priority:** High
**Check:** Is `HEAD` detached, but pointing exactly to a local branch tip? (`git branch --points-at HEAD`)

In Stacked Diffs, you often navigate to the "top" of a feature stack. Even if you are technically in a Detached HEAD state (via `git checkout <hash>` or `git prev/next`), if that commit is the tip of a named branch, we treat it as that branch.

- **Scenario:** User is detached at commit `A`, but `feature/login` also points to `A`.
- **Identity:** `feature_login`
- **Stability:** ⭐⭐⭐⭐⭐ (Stable as long as the branch ref moves with the stack)

### Layer 3: Semantic ID (The "Change-Id" Layer)
**Priority:** Medium (The Core of Stacked Diffs)
**Check:** Does the commit message contain a `Change-Id` or `Build-Id` trailer?

This is the critical layer for efficient Stacked Diffs. When you `amend` a commit, its Hash changes, but its `Change-Id` (generated by Gerrit hooks or `git-branchless`) remains constant. By using this ID, we preserve the build directory across code modifications.

- **Scenario:** User amends a commit in the middle of a stack. Hash changes `abc` -> `def`, but `Change-Id: I123...` persists.
- **Identity:** `change-I123...` (truncated)
- **Stability:** ⭐⭐⭐⭐⭐ (Persists across amends and rebases)

### Layer 4: Semantic Content (The "Slug" Layer)
**Priority:** Low (Heuristic Fallback)
**Check:** Generate a "slug" from the commit subject line. (`git log -1 --format=%f`)

If no Change-Id is present, we fall back to the commit title. As long as the developer modifies the *code* but keeps the *commit message title* unchanged, the build directory remains stable. This is a powerful heuristic for "quick fix" workflows.

- **Scenario:** User amends a commit "Fix typo in shader".
- **Identity:** `fix-typo-in-shader`
- **Stability:** ⭐⭐⭐ (Stable unless title changes)

### Layer 5: Physical Hash (The "Fallback" Layer)
**Priority:** Lowest
**Check:** Short Commit Hash. (`git rev-parse --short HEAD`)

The ultimate fallback. If we cannot derive any semantic meaning from the workspace state, we use the physical commit hash. This guarantees isolation but sacrifices incrementality across amends.

- **Scenario:** Detached HEAD, no branch, no Change-Id, empty or generic message.
- **Identity:** `detached-a1b2c3d`
- **Stability:** ⭐ (Changes on every amend)

---

## Workflow Compatibility Matrix

| User Action | Git State | Resolved Identity | Build Dir Behavior |
| :--- | :--- | :--- | :--- |
| `git checkout main` | On branch `main` | `main` | Reuses `build/main` |
| `git checkout feature/X` | On branch `feature/X` | `feature_X` | Reuses `build/feature_X` |
| `git branchless next` | Detached (at `feature/Y` tip) | `feature_Y` | Reuses `build/feature_Y` |
| `git commit --amend` | Detached (Hash changes) | `change-I8f2a...` | **Preserved!** (No rebuild) |
| `git rebase -i` | Detached (Hash changes) | `change-I8f2a...` | **Preserved!** (No rebuild) |
| `git checkout <hash>` | Detached (Random commit) | `fix-bug-title` | Reuses `build/fix-bug-title` |

## Implementation Guidelines

1. **Variable Expansion**: The `{{ branch }}` template variable in `builder` configuration will now resolve to this **Identity**, not just the literal Git branch name.
2. **New Variables**: We will expose `{{ git_sha }}` and `{{ git_ref }}` for scripts that strictly require the physical Git state.
3. **Sanitization**: All resolved identities must be sanitized (replace `/` with `_`, remove special chars) to be filesystem-safe.
