#!/usr/bin/env python3
import subprocess
import sys
import re
import os

def run_git(args, check=True):
    result = subprocess.run(['git'] + args, capture_output=True, text=True)
    if check and result.returncode != 0:
        print(f"Error running git {' '.join(args)}:\n{result.stderr}", file=sys.stderr)
        sys.exit(1)
    return result.stdout.strip()

def get_current_branch():
    return run_git(['rev-parse', '--abbrev-ref', 'HEAD'])

def get_stack_commits(base_branch):
    # Get commits from base to HEAD in reverse order (oldest first)
    # Output format: hash subject
    out = run_git(['log', '--reverse', '--pretty=format:%H %s', f'{base_branch}..HEAD'])
    if not out:
        return []
    lines = out.split('\n')
    commits = []
    for line in lines:
        parts = line.split(' ', 1)
        if len(parts) == 2:
            commits.append((parts[0], parts[1]))
    return commits

def slugify(text):
    # Simple slugify: lowercase, replace non-alphanumeric with -, trim
    text = text.lower()
    text = re.sub(r'[^a-z0-9]+', '-', text)
    text = text.strip('-')
    return text[:50] # Limit length

def generate_machete_file(base_branch, branches_tree):
    """
    Generates content for .git/machete ensuring proper tree structure.
    
    Args:
    - base_branch: The root branch.
    - branches_tree: A list of defined branches in topological order. 
      In a linear stack context, they are strictly sequential.
      
    If we are just slicing a linear stack, the structure is always:
    A -> B -> C -> D
    
    If multiple branches point to same commit, they are siblings?
    Or if the user forks logic?
    The current script only walks 'base..HEAD', which implies a single linear path.
    You cannot have a 'tree' (fork) within a single 'log base..HEAD' output 
    because HEAD has only 1 history line to base (unless merges involved, 
    but linear stack implies we ignore merge commits or treat them linearly).
    
    However, if an interactive session defines multiple branches on the SAME commit:
    Commit A -> branch1, branch2
    Then branch1 and branch2 are aliases. 
    In machete:
    main
        branch1
            branch2
    (This implies branch2 is child of branch1. If they point to same hash, diff is empty.)
    """
    lines = [base_branch]
    indent = "    "
    for i, branch in enumerate(branches_tree):
        prefix = indent * (i + 1)
        lines.append(f"{prefix}{branch}")
    
    return "\n".join(lines)

def get_git_dir():
    """Correctly locate .git directory, handling worktrees, submodules, and bare repos."""
    # 'git rev-parse --git-dir' returns the correct path for all cases:
    # - Standard: .git
    # - Worktree: /path/to/main/.git/worktrees/my-worktree
    # - Submodule: /path/to/super/.git/modules/my-submodule
    # - Bare: . (or absolute path)
    return run_git(['rev-parse', '--git-dir'])

def main():
    if len(sys.argv) > 1:
        base_branch = sys.argv[1]
    else:
        # Try to guess default branch
        base_branch = 'main'
        if run_git(['rev-parse', '--verify', 'main'], check=False) == "":
            base_branch = 'master'


    print(f"Assuming base branch: {base_branch}")
    
    commits = get_stack_commits(base_branch)
    if not commits:
        print("No commits found in stack (HEAD is equal to base or behind).")
        return

    # Interactive Mode
    import tempfile
    
    # 1. Prepare Instructions
    instructions = f"""
# Interactive Stack Slice
#
# Define where to create branches in your stack history ({base_branch}..HEAD).
#
# COMMANDS:
#  branch <name>   : Create/Update a branch pointing to this commit
#  b <name>        : Alias for branch
#  # <comment>     : Comments are ignored
#
# If no branch is defined for a commit, it will be part of the history of the next defined branch.
#
# OLDER COMMITS ARE AT THE TOP.
#
"""
    
    # 2. Prepare content
    content_lines = [instructions.strip()]
    for commit_hash, subject in commits:
        content_lines.append(f"\n# {commit_hash[:8]} {subject}")
        # Default: commented out suggest branch name (autogen)
        suggested_name = f"stack/{slugify(subject)}"
        content_lines.append(f"# branch {suggested_name}")

    with tempfile.NamedTemporaryFile(suffix=".txt", mode='w+', delete=False) as tf:
        tf_path = tf.name
        tf.write("\n".join(content_lines))
    
    # 3. Launch Editor
    editor = os.environ.get('GIT_EDITOR') or os.environ.get('EDITOR') or 'vim'
    # Try to find git's configured editor
    if not os.environ.get('GIT_EDITOR'):
        git_editor = run_git(['config', 'core.editor'], check=False)
        if git_editor:
            editor = git_editor

    print(f"Opening interactive editor ({editor})...")
    subprocess.call([editor, tf_path])
    
    # 4. Parse Result
    created_branches = []
    
    # We need to map which commit gets which branch.
    # The file format is linear. We can iterate through lines.
    # A 'branch' command applies to the *preceding* commit? 
    # Or should we structure it like 'pick'?
    # Let's change formats to be more like rebase -i: "command param # comment"
    # But here we want the user to INSERT branch points.
    
    # Let's re-read the format I chose:
    # # hash subject
    # # branch suggested_name
    
    # The user uncomments 'branch ...' line.
    # So we need to know which commit that line belongs to.
    
    with open(tf_path, 'r') as f:
        lines = f.readlines()
    
    os.unlink(tf_path)

    current_commit_hash = None
    commit_branch_map = {} # hash -> list of branch names

    for line in lines:
        line = line.strip()
        if not line: continue
        
        # Check for commit header
        # We formatted it as: # <hash> <subject>
        # But user might mess with comments.
        # We need a robust way. 
        # Actually, let's use the rebase-i format: "pick <hash> <subject>"
        # And user changes "pick" to "branch <name>"? No, that consumes the commit.
        # We want to TAG the commit.
        
        # Let's rely on the parsing logic:
        # We iterate lines.
        # If we see a line starting with "# <hash> ", we treat it as context for "current commit".
        # If we see "branch <name>" or "b <name>", we assign it to "current commit".
        
        match_commit = re.match(r'^# ([0-9a-f]{7,40}) (.*)', line)
        if match_commit:
            current_commit_hash = match_commit.group(1)
            # Find the full hash from our initial list to be safe? 
            # match_commit.group(1) is likely short hash.
            # Let's resolve 'current_commit_hash' to full hash if possible, 
            # or just use what we have if git accepts it.
            # Helper to find full hash from partial:
            for c_h, c_s in commits:
                if c_h.startswith(current_commit_hash):
                    current_commit_hash = c_h
                    break
            continue

        if line.startswith('#'): continue

        parts = line.split()
        cmd = parts[0]
        
        if cmd in ('branch', 'b') and len(parts) > 1:
            if not current_commit_hash:
                print(f"Warning: Found 'branch' command before any commit context: {line}")
                continue
            branch_name = parts[1]
            if current_commit_hash not in commit_branch_map:
                commit_branch_map[current_commit_hash] = []
            commit_branch_map[current_commit_hash].append(branch_name)

    if not commit_branch_map:
        print("No branches defined. Aborting.")
        return

    print("Applying changes...")
    
    # 5. Execute
    # Order matters for Machete? Machete file needs to be ordered by topology.
    # Our 'commits' list is ordered Oldest -> Newest.
    # We should iterate our original 'commits' list to maintain order in machete file.
    
    machete_branches = []
    
    for commit_hash, subject in commits:
        if commit_hash in commit_branch_map:
            for branch_name in commit_branch_map[commit_hash]:
                print(f"Creating {branch_name} at {commit_hash[:7]}")
                run_git(['branch', '-f', branch_name, commit_hash])
                machete_branches.append(branch_name)
    
    if not machete_branches:
        print("No branches were created.")
        return


    # If the file exists, we need to carefully merge.
    # 1. Read existing machete file
    existing_lines = []
    if os.path.exists(machete_path):
        with open(machete_path, 'r') as f:
            existing_lines = [l.rstrip() for l in f.readlines()]
    else:
        # If no file, initialize with base branch if it's not empty
        if base_branch:
             existing_lines = [base_branch]

    # Pre-processing: Remove any existing entries of the branches we are about to insert.
    # This prevents duplicates and allows "moving" branches in the tree.
    # Note: This implementation simply removes the line. If the removed branch had children,
    # those children will geographically remain, but their parentage might shift to the preceding line.
    # This is a known limitation, but sufficient for stack re-generation.
    
    cleaned_lines = []
    for line in existing_lines:
        bg_name = line.strip()
        if bg_name not in machete_branches:
            cleaned_lines.append(line)
        else:
            # Check if we are removing something that has children (look ahead)
            # For now, just print a debug/info if needed, but we proceed to remove.
            pass
            
    # 2. Logic to insert the new linear chain
    # The new chain is: base_branch -> machete_branches[0] -> machete_branches[1] ...
    
    # We need to find where 'base_branch' is in the existing file.
    # And then append the new branches as children of base_branch.
    
    # Limitation: This simple logic assumes we just append to the end of children of base_branch.
    # But if base_branch has other children, we are adding a sibling.
    
    new_lines = cleaned_lines
    
    if not new_lines:
        new_lines.append(base_branch)
        indent_level = 0

    # Find the line index of base_branch
    base_idx = -1
    base_indent = ""
    
    for i, line in enumerate(new_lines):
        if line.strip() == base_branch:
            base_idx = i
            base_indent = line[:len(line) - len(line.lstrip())]
            break
    
    if base_idx == -1:
        # base_branch not found in file.
        # This is tricky. Do we append it to root?
        # Let's just append it at the end as a new root for now or warn.
        print(f"Warning: Base branch '{base_branch}' not found in .git/machete. Appending as new root.")
        new_lines.append(base_branch)
        base_indent = ""
        base_idx = len(new_lines) - 1

    # Insert new branches after base_branch
    # We need to find the insertion point.
    # Insertion point is: after base_branch, and after all its current children (subtree).
    # Actually, machete format order doesn't strictly matter for siblings, 
    # but it's good to put it effectively.
    # Let's just insert immediately after base_branch line, 
    # but with correct indentation of indentation of base + 4.
    
    # Wait, if we insert immediately after, we push down existing children. 
    # That makes them previous siblings? No, order matters for display.
    # Let's append to the END of the subtree of base_branch.
    
    # Detecting subtree end:
    # Scan from base_idx + 1. Stop when indentation is <= base_indent.
    
    insertion_idx = base_idx + 1
    target_indent_len = len(base_indent) + 4 # Standard 4 space indent
    target_indent = " " * target_indent_len
    
    # If base_branch is root (indent 0), children have indent 4.
    
    while insertion_idx < len(new_lines):
        curr_line = new_lines[insertion_idx]
        curr_indent_len = len(curr_line) - len(curr_line.lstrip())
        
        if curr_indent_len <= len(base_indent) and curr_line.strip() != "":
            # Found a line with same or less indent -> end of subtree
            break
        insertion_idx += 1
        
    # Now insertion_idx is where we want to insert our new chain.
    
    to_insert = []
    # The new linear chain needs indentation relative to base_branch
    # machete_branches[0] is child of base_branch.
    # machete_branches[1] is child of machete_branches[0], etc.
    
    for i, branch in enumerate(machete_branches):
        # Indentation increases by 4 for each step in OUR new chain
        # relative to the PARENT (base_branch).
        depth = i + 1
        line_indent = " " * (len(base_indent) + (4 * depth))
        to_insert.append(f"{line_indent}{branch}")
        
    # Apply insertion
    new_lines[insertion_idx:insertion_idx] = to_insert
    
    machete_content = "\n".join(new_lines)
    
    with open(machete_path, 'w') as f:
        f.write(machete_content + "\n")
    
    print(f"\nUpdated {machete_path}")
    print("You can now run 'git machete status' to see the tree.")



if __name__ == "__main__":
    main()
