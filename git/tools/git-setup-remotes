#!/bin/sh
# git-setup-remotes
# POSIX-compliant script to configure git remotes for mirroring or contributing.

set -eu

# --- Configuration Helpers ---

# Get config value with optional default
# Usage: get_config <key> [default]
get_config() {
    key="$1"
    default="${2:-}"
    value=$(git config --get "$key" 2>/dev/null || true)
    if [ -z "$value" ]; then
        echo "$default"
    else
        echo "$value"
    fi
}

# --- Platform & Host Resolution ---

# Get configured host for a platform, with fallback to built-ins
# Usage: get_platform_host <platform_name>
get_platform_host() {
    name="$1"
    # 1. Try config: platform.<name>.host
    host=$(get_config "platform.$name.host")
    if [ -n "$host" ]; then
        echo "$host"
        return
    fi

    # 2. Fallback to known defaults
    case "$name" in
        github)    echo "github.com" ;;
        gitlab)    echo "gitlab.com" ;;
        gitea)     echo "gitea.com" ;;
        codeberg)  echo "codeberg.org" ;;
        bitbucket) echo "bitbucket.org" ;;
        azure)     echo "dev.azure.com" ;;
        *)         echo "" ;;
    esac
}

# Identify platform name from a hostname
# Usage: identify_platform_by_host <hostname>
identify_platform_by_host() {
    host="$1"
    
    # 1. Check built-ins
    case "$host" in
        github.com)          echo "github"; return ;;
        gitlab.com)          echo "gitlab"; return ;;
        gitea.com)           echo "gitea"; return ;;
        codeberg.org)        echo "codeberg"; return ;;
        bitbucket.org)       echo "bitbucket"; return ;;
        dev.azure.com)       echo "azure"; return ;;
        visualstudio.com)    echo "azure"; return ;;
    esac

    # 2. Fallback: return the host itself as the platform key
    echo "$host"
}

# Get platform page suffix (for .io/.page repos)
# Usage: get_platform_page_suffix <platform_name>
get_platform_page_suffix() {
    name="$1"
    # 1. Try config: platform.<name>.page-suffix
    suffix=$(get_config "platform.$name.page-suffix")
    if [ -n "$suffix" ]; then
        echo "$suffix"
        return
    fi

    # 2. Fallback to known defaults
    case "$name" in
        github)    echo "github.io" ;;
        gitlab)    echo "gitlab.io" ;;
        gitea)     echo "gitea.io" ;;
        codeberg)  echo "codeberg.page" ;;
        bitbucket) echo "bitbucket.io" ;;
        *)         echo "" ;;
    esac
}

# --- Logic ---

# Get current username for a specific platform
# Fallback chain: platform.<name>.user -> user.name
get_platform_user() {
    platform="$1"
    user=$(get_config "platform.$platform.user")
    if [ -z "$user" ]; then
        user=$(git config user.name 2>/dev/null)
    fi
    echo "$user"
}

# Get current repository name from origin URL or directory name
get_repo_name() {
    url=$(git remote get-url origin 2>/dev/null || echo "")
    if [ -n "$url" ]; then
        # Try to extract repo name from URL (remove .git)
        basename "$url" .git
    else
        basename "$PWD"
    fi
}

# Helper to resolve SSH alias to hostname
resolve_real_host() {
    _host="$1"
    # Normalize first
    _host=$(echo "$_host" | tr '[:upper:]' '[:lower:]')
    
    # Try ssh -G
    if command -v ssh >/dev/null 2>&1; then
        # ssh -G output format: "hostname example.com" (case insensitive key)
        # We look for the first occurrence of "hostname"
        _resolved=$(ssh -G "$_host" 2>/dev/null | awk 'tolower($1)=="hostname" {print $2; exit}')
        if [ -n "$_resolved" ]; then
            _host="$_resolved"
        fi
    fi
    
    # Normalize known domains
    case "$_host" in
        ssh.github.com)          echo "github.com" ;;
        altssh.gitlab.com)       echo "gitlab.com" ;;
        ssh.dev.azure.com)       echo "dev.azure.com" ;;
        vs-ssh.visualstudio.com) echo "visualstudio.com" ;;
        altssh.bitbucket.org)    echo "bitbucket.org" ;;
        *)                       echo "$_host" ;;
    esac
}

# Extract hostname from a git URL
# Supports:
#   git@github.com:user/repo.git  -> github.com
#   https://github.com/user/repo  -> github.com
#   ssh://git@host:22/repo        -> host
extract_host_from_url() {
    url="$1"
    # Remove protocol prefix
    no_proto="${url#*://}"
    
    # Check for SCP-like syntax (user@host:path)
    # If no protocol prefix was removed (url == no_proto)
    if [ "$url" = "$no_proto" ]; then
        # Extract before ':'
        host_part="${url%%:*}"
        # Remove user@ if present
        host="${host_part#*@}"
    else
        # It had a protocol (http/https/ssh)
        # Extract before first slash
        host_part="${no_proto%%/*}"
        # Remove user@ if present
        host_part="${host_part#*@}"
        # Remove port if present
        host="${host_part%%:*}"
    fi
    echo "$host"
}

# Try to extract base name if it is a page repo
# Usage: get_page_base_name <repo>
# Returns: base_name (stdout) and exit 0 if match, else exit 1
get_page_base_name() {
    repo="$1"
    
    # Check against known suffixes
    # We check standard ones. Custom ones might be missed here unless we iterate all config.
    for p in github gitlab gitea codeberg bitbucket; do
        suffix=$(get_platform_page_suffix "$p")
        if [ -z "$suffix" ]; then continue; fi
        
        # POSIX string matching for suffix
        # We require a dot separator to avoid partial matches (e.g. "my-github.io" vs "my.github.io")
        # and to ensure the removal expansion works correctly.
        case "$repo" in
            *."$suffix")
                # It's a match! Extract base name.
                # ${var%pattern} removes shortest match from end
                echo "${repo%.$suffix}"
                return 0
                ;;
        esac
    done
    
    return 1
}

# Construct remote URL
# Usage: construct_url <platform> <user> <repo>
construct_url() {
    platform="$1"
    user="$2"
    repo="$3"
    
    # 1. Check for custom URL format override (Highest Priority)
    # This allows full control: "ssh://git@custom:2222/{user}/{repo}.git"
    custom_url=$(get_config "platform.$platform.url")
    if [ -n "$custom_url" ]; then
        # Simple template replacement
        echo "$custom_url" | sed "s/{user}/$user/g; s/{repo}/$repo/g"
        return
    fi

    # 2. Resolve Host
    host=$(get_platform_host "$platform")
    if [ -z "$host" ]; then
        # If we can't resolve a host from the name, and the name looks like a domain, use it.
        case "$platform" in
            *.*) host="$platform" ;;
            *) 
                echo "Unknown platform host for '$platform'. Configure 'platform.$platform.host' or 'platform.$platform.url'." >&2
                return 1
                ;;
        esac
    fi

    # 3. Check for SSH Alias override
    ssh_alias=$(get_config "platform.$platform.ssh-alias")
    
    # 4. Standard Construction
    if [ -n "$ssh_alias" ]; then
        echo "$ssh_alias:$user/$repo.git"
    else
        echo "git@$host:$user/$repo.git"
    fi
}

setup_mirroring() {
    current_repo=$(get_repo_name)
    echo "Configuring mirrors for repo: $current_repo"

    # Read mirrors list
    mirrors=$(get_config "ginshio.remotes.mirrors" "github,gitlab,codeberg,bitbucket")
    
    # Analyze Origin
    origin_url=$(git remote get-url origin 2>/dev/null)
    origin_host=""
    if [ -n "$origin_url" ]; then
        origin_host=$(extract_host_from_url "$origin_url")
        origin_real_host=$(resolve_real_host "$origin_host")
    fi

    # Detect Page Repo status
    page_base=""
    if page_base=$(get_page_base_name "$current_repo"); then
        is_page="true"
        echo "Detected Page Repository. Base name: $page_base"
    else
        is_page="false"
    fi

    # Pre-calculate mirror URLs and check if origin is covered
    origin_covered=false
    
    # We need to store the calculated URLs to avoid recalculating
    # Since POSIX sh doesn't have arrays, we'll use a temporary file or string manipulation.
    # String manipulation with a separator is easiest.
    mirror_urls=""
    
    old_ifs="$IFS"
    IFS=","
    for platform in $mirrors; do
        platform=$(echo "$platform" | xargs)
        [ -z "$platform" ] && continue
        
        user=$(get_platform_user "$platform")
        if [ -z "$user" ]; then
            echo "No user defined for $platform. Skipping."
            continue
        fi

        # Calculate Target Repo Name
        target_repo="$current_repo"
        if [ "$is_page" = "true" ]; then
            suffix=$(get_platform_page_suffix "$platform")
            if [ -n "$suffix" ]; then
                target_repo="$page_base.$suffix"
            fi
        fi

        url=$(construct_url "$platform" "$user" "$target_repo")
        
        if [ -n "$url" ]; then
            # Check coverage
            # We compare the host of the constructed URL with the origin host
            constructed_host=$(extract_host_from_url "$url")
            constructed_real_host=$(resolve_real_host "$constructed_host")
            
            # Host comparison using resolved hosts
            if [ -n "$origin_real_host" ] && [ "$constructed_real_host" = "$origin_real_host" ]; then
                origin_covered=true
            fi
            
            # Append to list (newline separated)
            mirror_urls="${mirror_urls}${url}
"
        fi
    done
    IFS="$old_ifs"

    # Apply Configuration
    
    # If origin is covered by the mirrors list, we want to REPLACE the origin URL
    # with the standardized one from the list.
    # If not covered, we want to KEEP the origin URL and append mirrors.
    
    first_url=true
    
    if [ "$origin_covered" = "false" ] && [ -n "$origin_url" ]; then
        # Not covered: Set origin as the first URL
        git remote set-url --push origin "$origin_url"
        first_url=false
    fi

    # Iterate over calculated URLs
    # Use printf to safely handle newlines
    printf "%s" "$mirror_urls" | while IFS= read -r url; do
        [ -z "$url" ] && continue
        
        if [ "$first_url" = "true" ]; then
            # This is the first URL we are setting (either because origin was covered/replaced, or origin was empty)
            # This overwrites the existing push URL (which is what we want if covered)
            echo "  + Setting primary push URL: $url"
            git remote set-url --push origin "$url"
            first_url=false
        else
            # Add subsequent URLs
            # Avoid duplicates if we are in not-covered mode and the URL happens to match origin exactly
            # We also check resolved hosts here to avoid duplicate aliases
            url_host=$(extract_host_from_url "$url")
            url_real_host=$(resolve_real_host "$url_host")
            
            if [ "$origin_covered" = "false" ] && [ -n "$origin_real_host" ] && [ "$url_real_host" = "$origin_real_host" ]; then
                 continue
            fi
            
            echo "  + Adding mirror: $url"
            git remote set-url --add --push origin "$url"
        fi
    done
}

setup_contributor() {
    echo "Configuring contributor mode..."
    
    # 1. Handle Upstream
    # If 'upstream' exists, we assume it's already set up.
    # If not, we rename 'origin' to 'upstream' (assuming user cloned from official repo).
    if git remote get-url upstream >/dev/null 2>&1; then
        echo "  'upstream' remote already exists."
        upstream_url=$(git remote get-url upstream)
    else
        echo "  Renaming 'origin' to 'upstream'..."
        git remote rename origin upstream
        upstream_url=$(git remote get-url upstream)
    fi

    # 2. Handle Origin (Fork)
    if git remote get-url origin >/dev/null 2>&1; then
        echo "  'origin' remote already exists."
    else
        current_repo=$(get_repo_name)
        
        # Determine Platform from Upstream URL
        host=$(extract_host_from_url "$upstream_url")
        platform=$(identify_platform_by_host "$host")
        
        if [ -z "$platform" ]; then
            # If we can't identify the platform name, use the host as the platform key
            # This allows users to set `platform.my-gitea.com.user`
            platform="$host"
            echo "  Identified host: $host (using as platform key)"
        else
            echo "  Identified platform: $platform (host: $host)"
        fi
        
        user=$(get_platform_user "$platform")
        
        if [ -z "$user" ]; then
            echo "Could not determine user for platform '$platform'. Please configure 'platform.$platform.user'." >&2
            exit 1
        fi
        
        # For forks, we assume the repo name is the same as upstream
        # unless it's a page repo? Usually forks of page repos keep the name or change it to user.page.
        # For simplicity, we keep the repo name.
        
        url=$(construct_url "$platform" "$user" "$current_repo")
        
        if [ -n "$url" ]; then
            echo "  Adding 'origin' pointing to $url"
            git remote add origin "$url"
        else
            echo "Failed to construct URL for fork." >&2
            exit 1
        fi
    fi
}

# --- Main ---

MODE="mirror"

# Simple argument parsing
while [ $# -gt 0 ]; do
    case "$1" in
        --contribute|-c)
            MODE="contribute"
            shift
            ;;
        --mirror|-m)
            MODE="mirror"
            shift
            ;;
        --help|-h)
            echo "Usage: git-setup-remotes [--mirror | --contribute]"
            echo ""
            echo "Configuration (git config --global):"
            echo "  ginshio.remotes.mirrors      Comma-separated list of mirror platforms (default: github,gitlab,codeberg)"
            echo "  platform.<name>.user         Username for specific platform"
            echo "  platform.<name>.url          Custom URL template (e.g. ssh://git@host/{user}/{repo}.git)"
            echo "  platform.<name>.host         Hostname (if not using custom URL)"
            echo "  platform.<name>.ssh-alias    SSH alias for platform (e.g. gitlab.com -> gitlab)"
            echo "  platform.<name>.page-suffix  Suffix for page repos (e.g. github.io)"
            exit 0
            ;;
        *)
            echo "Unknown argument: $1" >&2
            exit 1
            ;;
    esac
done

if [ "$MODE" = "mirror" ]; then
    setup_mirroring
else
    setup_contributor
fi
